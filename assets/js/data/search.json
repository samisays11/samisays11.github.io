[ { "title": "My Top Ten Books on How to Engineer Consumer Behaviors", "url": "/posts/human-behavior/", "categories": "BookList", "tags": "psychology, consumer behavior, behavioral engineering", "date": "2022-07-23 14:08:00 -0500", "snippet": "Coming soon‚Ä¶üöß" }, { "title": "Top Ten Books on Engineering Virality Into Products", "url": "/posts/virality/", "categories": "BookList", "tags": "psychology, consumer behavior, behavioral engineering, viral adoption", "date": "2022-07-23 14:08:00 -0500", "snippet": "Coming soon‚Ä¶üöß" }, { "title": "Portfolio Projects üíº", "url": "/posts/portfolio/", "categories": "Portfolio", "tags": "swift, ios, projects, ios developer", "date": "2022-07-18 14:08:00 -0500", "snippet": "Coming soon‚Ä¶üöß" }, { "title": "How to Drag & Reorder CollectionView Cells", "url": "/posts/drag-and-drop/", "categories": "iOS, Swift Tutorials", "tags": "swift, ios, uikit, collectionview, gesture recognizers", "date": "2022-07-18 14:08:00 -0500", "snippet": "Reordering Collection View Cells is a feature that was introduced in iOS 9. It is a surprisingly easy interaction to build, both in collectionviews and tableviews. By leveraging the UILongPressGestureRecognizer class we can easily implement a drag and reorder interaction of collectionview cells. It‚Äôs simply matter of updating the collectionview‚Äôs data model to match the re-order.OverviewThere are two things that needs to be done for us to implement the drag to reorder interaction: Setup long press gesture recognizer to handle interactive drag movement. Override collectionview‚Äôs two delegate methods that‚Äôs responsible for reordering cells. Getting StartedInitialize and add a long press gesture recognizer to your collectionview:let longGestureGesture = UILongPressGestureRecognizer(target: self, action: #selector(handleLongPressGesture))collectionView.addGestureRecognizer(longGestureGesture)Don‚Äôt forget to create a target selector for your gesture recognizer: @objc fileprivate func handleLongPressGesture(gesture: UILongPressGestureRecognizer) { switch gesture.state { case .began: guard let targetIndexPath = collectionView.indexPathForItem(at: gesture.location(in: collectionView)) else {return} collectionView.beginInteractiveMovementForItem(at: targetIndexPath) case .changed: collectionView.updateInteractiveMovementTargetPosition(gesture.location(in: collectionView)) case .ended: collectionView.endInteractiveMovement() default: collectionView.cancelInteractiveMovement() } }There is only 3 gesture states we are concerned with: the .began, .changed, and .ended states.The .began case logic:Once the user long press interaction begins, we want to locate the cell they are long pressing, then we want to start the movement of that cell, so that when the user drags the cell, the cell will move accordingly with the finger. To accomplish this we leverage the collectionview‚Äôs indexPathForItem method to grab the cell‚Äôs indexPath and then we signal to the collectionview to begin interactive movement through it‚Äôs beginInteractiveMovementForItem method. Note: The targetIndexPath constant is unwrapped because the indexPathForItem method is not guaranteed to return an indexPath. Since the user might be long pressing between cells or the collectionview‚Äôs padded area, might not necessarily have a location, hence the unwrapping.The .changed, .ended and default cases are pretty straightforward and self-explanatory.Updating CollectionView‚Äôs Data ModelWith the long press gesture recognizer setup to handle collectionview interaction, we have to update the data models// Responsible for collectionView Re-order//1 override func collectionView(_ collectionView: UICollectionView, canMoveItemAt indexPath: IndexPath) -&gt; Bool { return true } //2 override func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) { // first grab and remove item at sourceIndex let photo = photosArray.remove(at: sourceIndexPath.item) photosArray.insert(item, at: destinationIndexPath.item) } This method enables us to specify which cells we want to allow the user to move. This can be pretty useful when dragging and reordering items between multiple sections. It can be used to enabled or disable reordering interaction for a specific cell or even an entire collectionview section. Here we return true since we want all our cells to be movable in this scenario. This method is responsible for updating our data model. Making sure the cells order matches the data model‚Äôs. When this method is not implemented the cells will essentially return to their old positions when the collectionview is scrolled.When a cell is moved to a new position, the original index position in the array is removed and the new index position Is inserted into the array. Note: The sourceIndexPath is the Initial index path where the long press gesture begins. While the destinationIndexPath is the final index path the user drags the cell.Done üôå‚úäü•≥üéâüëèThat‚Äôs all. Build and Run the project, long-press a cell and reorder it.ResourcesDownload the source code. The project contains a collectionview that has two sections, each cell cell contains a letter from the alphabet or an emoji. Drag to reorder the cells to make words." }, { "title": "The Modern iOS 14 Photo Picker", "url": "/posts/PHImagePicker/", "categories": "iOS, Swift Tutorials", "tags": "swift, ios, phpickerviewController, phassetcollections, phfetchresult, phassets, photo picker, uikit, phpicker, photosui", "date": "2022-07-18 14:08:00 -0500", "snippet": "Prior to iOS 14, the quickest and simplest way to fetch photos from the user‚Äôs photo library was through the UIImagePickerController class. However, starting from iOS 14.0, Apple is providing us developers a new way to access the user‚Äôs photo library using the new PHPickerViewController class. A reusable class built on top of the PhotosUI framework rather than UIKit. It makes photo and video selection a much modern experience for apps.Why Even Use PHPickerViewController?Unless your app still supports anything below iOS 14, dumping the old guard of UIImagePickerController should be very easy when you consider some of the disadvantages that came with the old guy.The old UIImagePickerController was fairly basic and limited. It had no search or filtering functionality and did not support multi-item selection. Although the UIImagePickerController class is not currently deprecated, if you look at the header file you‚Äôll see the API marked with this:API_DEPRECATED(\"Will be removed in a future release, use PHPicker.\", ios(11, API_TO_BE_DEPRECATED));So expect deprecation in future updates.What‚Äôs the BuzzHere‚Äôs a list of why PHPickerViewController is awesome No more permission alerts. Developer don‚Äôt have to specify the Privacy - Photo Library Usage Description key in the info.plist file anymore, because there won‚Äôt be any need for alert views that‚Äôs asking for permission. Runs in a separate process. Although the PHPickerViewController might appear to be present inside the host app, it runs in a separate process. Built-in privacy. Since PHPickerViewController runs in a separate process, only the content selected by the user is shared with the Host App. Unlike the UIImagePickerViewController, you can‚Äôt programmatically take a screenshot of this picker view or access any content that‚Äôs not selected by the user. Built-in search. Searching photos is a built-in feature in PHPickerViewController, and the UI is similar to that of the Photos app. Multi-selection. PHPickerViewController comes equiped with multi-selection capabilty and also allows the developer to limit the number of photos a user can select by setting the selectionLimit property in PHPickerConfiguration.Implementing PHPickerViewControllerGetting started with the new PHPickerViewController API is pretty straightforward. It requires a configuration and uses the traditional delegate model to alert‚Äôs us when item selection is complete.The PHPickerViewController takes an instance of PHPickerConfiguration as an initializer argument. var configuration = PHPickerConfiguration() let picker = PHPickerViewController(configuration: configuration)PHPickerConfigurationThe PHPickerConfiguration provides us with three properties we can use to customize the PHPickerViewController. selectionLimit - This property specifies the number of items a user can select. The default value is 1, while the value 0 specifies unlimited selection. The below configuration limits the selection to 10 items. filter - This property restricts the type of items that can be displayed (images, livePhotos or videos). Setting the value to nil will display all the supported items. The below configuration displays only the live photos and images. preferredAssetRepresentationMode - This determines how an item provider should represent an asset. The default value is automatic. The below configuration sets the asset‚Äôs representation mode to automatic. Note: By default the selectionLimit is set to 1, and there is no filter.// remember to import PhotosUI var configuration = PHPickerConfiguration() configuration.selectionLimit = 10 configuration.filter = .any(of: [.images,.livePhotos]) configuration.preferredAssetRepresentationMode = .automatic let picker = PHPickerViewController(configuration: configuration) picker.delegate = self present(picker, animated: true, completion: nil)PHPickerViewControllerDelegateAccessing selected items from the PHPickerViewController is simply a matter of implementing the PHPickerViewControllerDelegate , which has just one method:picker‚Äôs didFinishPicking method func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) { }The method comes with a result object which is an array of type PHPickerResult which contains an object of NSItemProvider. Now let‚Äôs see how we can parse selected images from this item provider object.Parsing Selected Images from ItemProviderfunc picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) { // Please note that your app is responsible for the presentation and dismissal of the picker. The picker does not manage the display itself. dismiss(animated: true, completion: nil) guard !results.isEmpty else { return } for result in results { let itemProvider = result.itemProvider if itemProvider.canLoadObject(ofClass: UIImage.self) { itemProvider.loadObject(ofClass: UIImage.self) { (image, error) in DispatchQueue.main.async { if let image = image as? UIImage { // WE NOW HAVE THE UIIMAGE OBJECT } } } } }}The for loop will go through all selected items in the returned results, and process all items by checking if the itemProvider can load a UIImage object. Note: There is no support for automatic compression. The picker‚Äôs itemProvider will always return the original image with full dimensions. It‚Äôs up to the developer to perform necessary compressions or edition.Parsing LivePhotosParsing live photos is quite similar to parsing images. The PhotosUI framework provides us with a PHLivePhoto object that can be used to load live photos from the itemProvider:let itemProvider = result.itemProviderif itemProvider.canLoadObject(ofClass: PHLivePhoto.self) { itemProvider.loadObject(ofClass: PHLivePhoto.self) { [weak self] livePhoto, error in DispatchQueue.main.async { if let livePhoto = livePhoto as? PHLivePhoto { // WE NOW HAVE ACCESS TO THE SELECTED LIVE PHOTO } } } } Note: The PhotosUI framework provides us with a PHLivePhotoView class that we can use to display livePhotos.Parsing VideosParsing videos is a little more work compared to photos and livePhotos.First we check itemProvider for item that conforms to ‚Äúpublic.movie‚Äù through a UTType.movie.identifier string. Then we use the itemProvider‚Äôs loadFileRepresentation(forTypeIdentifier: ) method to load and copy the video‚Äôs url. let movieTypeIdentifier = UTType.movie.identifier if itemProvider.hasItemConformingToTypeIdentifier(movieTypeIdentifier) { itemProvider.loadFileRepresentation(forTypeIdentifier: movieTypeIdentifier) {[weak self] url, error in guard error == nil else{ print(error) return } // receiving the video-local-URL / filepath guard let url = url else {return} // create a new filename let fileName = \"\\(Int(Date().timeIntervalSince1970)).\\(url.pathExtension)\" // create new URL let storedVideoUrl = URL(fileURLWithPath: NSTemporaryDirectory() + fileName) // copy item to APP Storage try? FileManager.default.copyItem(at: url, to: storedVideoUrl) DispatchQueue.main.async { // WE NOW HAVE ACCESS TO OUR VIDEO'S URL in storedVideoUrl } } }Final TipIf your configuration‚Äôs filter allows the user to choose any type of asset ‚Äî a video, a live photo, or a normal photo ‚Äî you‚Äôre going to want to distinguish what type the user actually chose. This turns out to be no simple matter.After a great deal of experimentation and reading around, I‚Äôve settled on a formula like this:// itemProvider is the PHPickerResult's itemProvider if itemProvider.hasItemConformingToTypeIdentifier(UTType.movie.identifier) { // it's a video } else if itemProvider.canLoadObject(ofClass: PHLivePhoto.self) { // it's a live photo } else if itemProvider.canLoadObject(ofClass: UIImage.self) { // it's a photo }In that code, the order of the tests is deliberate. A live photo can be supplied in a simple UIImage representation, so if we test for images before live photos, we won‚Äôt learn that the result is a live photo.DrawbacksAlthough the PHPickerViewController offers a modern privacy-centric API that allows us to access photos and videos, It‚Äôs important to note that it currently does not offer any photo or video capturing capability. We still rely on it‚Äôs predecessor the UIImagePickerController for that.Resources Sample PHPicker Project Apple‚Äôs WWDC Video Resource Another Great Article On The Topic" }, { "title": "How To Remove Empty PHAssetCollections from a PHFetchResult", "url": "/posts/How-to-remove-empty-albums/", "categories": "iOS, Swift Tutorials", "tags": "swift, ios, photokit, phassetcollections, phfetchresult, phassets, custom photo picker, uikit", "date": "2022-07-10 14:08:00 -0500", "snippet": "fileprivate var smartAlbums = PHFetchResult&lt;PHAssetCollection&gt;()fileprivate var userCreatedAlbums = PHFetchResult&lt;PHAssetCollection&gt;()fileprivate func fetchPhotoAssets(){/* fetches all smart albums like favorites, selfies, screenshots, livephotos, panaramas etc in the user's photo library and stores it in a variable named \"smartAlbums\"*/smartAlbums = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .albumRegular, options: nil)// fetches all of the user-created albums in the user's photo library and stores it in a variable named \"userCreatedAlbums\"userCreatedAlbums = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .albumRegular, options: nil)}If you‚Äôve worked with the PhotoKit framework in the past to build a custom image picker, I‚Äôm sure you‚Äôve had to write a similar code to the one above to fetch user‚Äôs smart albums and user-created albums.The problem is users probably have a handful of empty albums in their photos library. To prevent us from cluttering the UI with empty PHAssetCollections there is a way for us to fetch only PHAssetCollections that contains at least one PHAsset (photo or video).We accomplish that by applying predicate on a PHFetchOptions object. See below:fileprivate func fetchPhotoAssets(){// fetches all of the non-empty user-created albums in the user's photo library and stores it in a variable named \"userCreatedAlbums\" let userCreatedAlbumsOptions = PHFetchOptions() userCreatedAlbumsOptions.predicate = NSPredicate(format: \"estimatedAssetCount &gt; 0\") userCreatedAlbums = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .albumRegular, options: userCreatedAlbumsOptions)}" }, { "title": "Let's Build a Custom Image Picker Just like Instagram Stories", "url": "/posts/How-to-build-Instagram-PhotoPicker/", "categories": "iOS, Swift Tutorials", "tags": "swift, ios, photokit, phassetcollections, phfetchresult, phassets, custom photo picker, uikit", "date": "2022-06-26 22:33:00 -0500", "snippet": "What Are We Building ?In this tutorial, i will walk you through how to build a clone of Instagram‚Äôs Story Photo Picker feature.If you are not familiar with what that looks like there is a gif demo of it below. For clarity we will be focusing exclusively on the custom photo picker functionality. All the user-interface, gesture animations, and transition animation related code are in the Starter Project. Dev Environment Swift 5, iOS 14, Xcode 13.4.1 Project DemoWhat You‚Äôll LearnHave you ever wondered how 3rd party apps like Instagram or Snapchat can access the photo library so seamlessly to retrieve and display our photos and albums in their custom made UIs? PhotoKit is the magical framework that makes that possible.At the end of this tutorial you‚Äôll know: How to Setup and Ask for User‚Äôs Photo Library Permission. How to Fetch Smart Albums and User-Created Albums. How to Fetch all Photo Assets in a Specific Album. How to Retrieve Images from Assets. How to use the retrieved PHAssets and PHAssetCollections to power our UI. How to use the PHPickerViewController to Search and Select specific Photo Assets. How to use the PHPhotoLibraryChangeObserver protocol to keep our assets up to date.Getting StartedLike many privacy-centric iOS APIs, the PhotoKit requires us to request the user‚Äôs permission before we can access the user‚Äôs photo library. To get this permission, we use the PHPhotoLibrary, a shared object that manages access to the photo library.Modifying Info.plist Before Requesting AuthorizationDownload the Starter Project and open the starter folder. Double click on the InstaPhotoPicker.xcodeproj file and navigate to the info.plist file in the root directory. The first step to Requesting Authorization is to add a key to the Info.plist file that explains why you need permission to access the user‚Äôs photo library.To do this you will need to: Open the Info.plist file. Right-click Information Property List and select the Add Row option. A new line will be displayed. Start typing Privacy - Photo Library Usage Description in the new row‚Äôs Key column and press enter. In the Value column, type in whatever usage description you want the alert dialog to show the user the first time iOS request for permission. For this tutorial we‚Äôll just go with ‚ÄúAccess to Photo Library Allows you to upload media from your Camera Roll to InstaPhotoPicker‚Äù as our request description.Your Info.plist should look like this: Requesting Authorization to Access User‚Äôs Photo LibraryOpen your ViewController.swift file in the starter project and add the following code inside your getPhotoPermission method in the Photokit section://MARK: - Photokit fileprivate func getPhotoPermission(completionHandler: @escaping(Bool) -&gt; Void) { // 1 guard PHPhotoLibrary.authorizationStatus() != .authorized else { completionHandler(true) return } // 2 PHPhotoLibrary.requestAuthorization(for: .readWrite) { status in switch status { case .notDetermined: // The user hasn't determined this app's access. print(\"notDetermined\") // completionHandler(false) case .restricted: // The system restricted this app's access. print(\"restricted\") completionHandler(false) case .denied: // The user explicitly denied this app's access. print(\"denied\") completionHandler(false) case .authorized: // The user authorized this app to access Photos data. print(\"authorized\") completionHandler(true) case .limited: // The user authorized this app for limited Photos access. print(\"limited\") completionHandler(true) @unknown default: fatalError() } } } This gets us the current authorization status from PHPhotoLibrary. If we‚Äôve already been granted authorization from prior prompts, we call the completion handler with a value of true and return out of the method. If authorization has not been previously granted or requested, we request it. When requesting authorization, iOS displays an alert that asks for user‚Äôs permission, upon user‚Äôs selection it passes back the user‚Äôs selection as a PHAuthorizationStatus object.We then call our completion handler and return true if the status (PHAuthorizationStatus) value is .authorized, or .limited, otherwise we return false. Note: Prior to iOS 14 PHAuthorizationStatus enum, did not contain a .limited, or .restricted status options. This is something to keep in mind if you‚Äôre also building for iOS 13 and below.Finalizing AuthorizationRun the project, click on the Enable photo access button. On tap iOS will ask for permission to let InstaPhotoPicker access the photo library. If you are building for iOS 13 or less tap OK, on iOS 14 tap Allow Access to All Photos.Great job! and just like that we are done with: How to Setup and Ask for User‚Äôs Photo Library Permission.Understanding Photokit‚Äôs Main ObjectsBefore we proceed to actually fetching photos and videos. It‚Äôs important you get a quick overview of the main objects we will be working with. When working with PhotoKit, we‚Äôll be dealing alot with these 3 objects: PHAssets TL;DR &rarr; Basically a metadata that represents an image, video, or Live Photo in the Photos library. PHAssetCollections TL;DR &rarr; A group of PHAssets. Basically a user-created album, or an ios smart album. PHFetchResults TL;DR &rarr; Basically PhotosKit's smart array that fetches and auto caches objects like PHAssets or PHAssetCollection.PHAssets First let‚Äôs make something absolutely clear, the PHAsset object is not an actual video or photo object. Don‚Äôt confuse it for a UIImage object. It‚Äôs a metadata that represents the image, LivePhoto, or video as it resides in the user‚Äôs photo library. It‚Äôs an immutable object that provide us the information we need to get the actual UIImage object or video URL, along with tons of other informations about them like their creation and modification dates, location data, favorite and hidden status etc.PHAssetCollections Sometimes you need to retrieve a group of assets, like in the case of an album in the user‚Äôs photo library. These are usually returned as a PHAssetCollection object. In essence, this is PhotosKit‚Äôs representation of an Album or Moment in the photo library.PHFetchResult A simplified way of thinking of PHFetchResult is to consider it an array, which it is. It contains all the same methods and conventions of arrays, such as count() and index(of:). Plus, it intelligently handles fetching data, caching it and re-fetching it as needed. You‚Äôll be fine if you think of PHFetchResult as an intelligent array of assets or collections. Ok that makes sense üëçSetting Up Photo Asset‚Äôs Data ModelsNow that you got the gist of the main objects we will be using to fetch our photos and albums, it‚Äôs time to set up our data models. Still in our ViewController.swift, at the top of the file, add these under the marked Properties sections://MARK: - Properties // 1 fileprivate var allPhotosInCurrentAlbum = PHFetchResult&lt;PHAsset&gt;() // 2 fileprivate var smartAlbums = [PHAssetCollection]() // 3 fileprivate var userCreatedAlbums = PHFetchResult&lt;PHAssetCollection&gt;() // 4 fileprivate let listOfsmartAlbumSubtypesToBeFetched: [PHAssetCollectionSubtype] = [.smartAlbumUserLibrary, .smartAlbumFavorites, .smartAlbumVideos, .smartAlbumScreenshots]For simplicity, i will be referring to PHFetchResult as a smart-array. In essence, think of it as initializing an empty smart-array we will use in holding all the photos and videos we will be fetching from the photos library. Initializing a regular array to hold the four smart-albums we will be fetching. Initializing a smart-array that will hold all the user-created albums. We will only be fetching those four distinct smart-albums from the photo library. This is a list we will use to filter for them.You might be thinking, ‚ÄúHey, what is this PHAssetCollectionSubtype thing ?‚Äù Well, PHAssetCollectionSubtype is simply an enumerable value that describes the particular subtype of a PHAssetCollection. Basically a way for us to specify which exact smart albums we want to fetch. Fetching Photo Assets and AlbumsStill in the ViewController.swift file go to the fetchPhotoLibraryAssets method below the marked Photokit section and add the following code ‚Üì//MARK: - PhotoKits fileprivate func fetchPhotoLibraryAssets() { // 1 let authStatus = PHPhotoLibrary.authorizationStatus() guard authStatus == .authorized || authStatus == .limited else {return} // 2 DispatchQueue.main.async { self.askPhotoPermissionView.updateTexts() } // 3 for collectionSubType in listOfsmartAlbumSubtypesToBeFetched { if let smartAlbum = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: collectionSubType, options: nil).firstObject { smartAlbums.append(smartAlbum) } } // 4 let userCreatedAlbumsOptions = PHFetchOptions() userCreatedAlbumsOptions.predicate = NSPredicate(format: \"estimatedAssetCount &gt; 0\") userCreatedAlbums = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .albumRegular, options: userCreatedAlbumsOptions) // 5 let fetchOptions = PHFetchOptions() let sortDescriptor = NSSortDescriptor(key: \"creationDate\", ascending: false) fetchOptions.sortDescriptors = [sortDescriptor] allPhotosInCurrentAlbum = PHAsset.fetchAssets(with: fetchOptions) // 6 DispatchQueue.main.async { self.mediaPickerView.bindDataFromPhotosLibrary(fetchedAssets: self.allPhotosInCurrentAlbum, albumTitle: \"Recents\") } } This gets us the current authorization status from PHPhotoLibrary. If we‚Äôve not been granted authorization, we return out of the method. This updates a UILabel‚Äôs text in the askPhotoPermissionView. Since the PhotoKit‚Äôs methods runs in the background thread, it‚Äôs important to update UI related stuff on the main thread. When retrieving assets from the photo library with PHFetchResult, we can use a PHAssetCollectionSubtype object to retrieve a specific type of smart album. Here, we loop through our listOfsmartAlbumSubtypesToBeFetched and then we use the PHAssetCollection‚Äôs fetchAssetCollection method to fetch and append the recent, favorites, videos, and screenshot smart albums to the smartAlbums array we declared earlier. When retrieving user created albums or smart albums, we can use a PHFetchOptions object to apply a set of sorting paramters to indicate how we would like the retrieved assets to be sorted. Here, we create a PHFetchOptions object and use a predicate to specify that we only want to fetch user created albums that contains at least one photo or video asset. Here we create a sort descriptor that sorts assets by creation date from newest to oldest, and then we apply it to our PHFetchOptions object, before we use the PHAsset‚Äôs fetchAssets method to retrieve all the photo and video assets in the photo library. PhotoKit‚Äôs methods runs in the background thread, so we jump to the main thread to pass our retrieved assets to the mediaPickerView for UI update. Displaying All Photo AssetsNow that we are done fetching data from the Photo Library‚Äôs Data Store let‚Äôs display them in our UI.Navigate to MediaPickerView.swift file in the Views folder and replace the collectionView‚Äôs cellforItem, numberOfItemsInSection and didSelectItem methods at the end of the class with these:// 1 func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell { let cell = collectionView.dequeueReusableCell(withReuseIdentifier: PhotoCell.cellReuseIdentifier, for: indexPath) as! PhotoCell cell.bind(asset: allPhotosInSelectedAlbum[indexPath.item]) return cell }// 2 func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int { return allPhotosInSelectedAlbum.count }// 3 func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) { guard let cell = collectionView.cellForItem(at: indexPath) as? PhotoCell else {return} let asset = allPhotosInSelectedAlbum[indexPath.item] let image = getAssetThumbnail(asset: asset, size: PHImageManagerMaximumSize) cell.thumbnailImageView.image = image delegate?.handleTransitionToStoriesEditorVC(with: cell.thumbnailImageView) } Here we are binding each photo‚Äôs asset to each individual cell‚Äôs UI. Here is a good example of how you treat PHFetchResult as an array. We are Returning the number of assets in the PHFetchResult as the number of items in the collectionView. Here we are getting the selected cell‚Äôs imageView and asset, then calling the getAssetThumbnail method to fetch the asset‚Äôs highest quality image. Then a delegate to handle the transition animation to StoriesEditorVC. Note: To request the maximum possible size for a PHAsset‚Äôs image we use the PHImageManagerMaximumSize.Getting UIImage from Photo AssetThe getAssetThumbnail method in the Constants.swift file inside the Misc folder is responsible for requesting a PHAsset‚Äôs image from the PHImageManager. In essence, this is how we convert a PHAsset object to a UIImage object. I suggest you click on the method and take a look at the code:public func getAssetThumbnail(asset: PHAsset, size: CGSize) -&gt; UIImage? { // 1 let manager = PHImageManager.default() let options = PHImageRequestOptions() options.isSynchronous = true options.isNetworkAccessAllowed = true var thumbnail: UIImage? // 2 manager.requestImage(for: asset, targetSize: size, contentMode: .aspectFill, options: options) {(imageReturned, info) in guard let thumbnailUnwrapped = imageReturned else {return} thumbnail = thumbnailUnwrapped } return thumbnail} We instantiate PHImageManager with PHImageRequestOptions. Here we are requesting the image from the image manager. Providing the asset, size, content mode, and options. Size is the size at which you would like the image returned. contentMode is how you would like the image to fit within the aspect ratio of the size. The default value is aspectFill. And then finally we return the requested image in the result handler.Alright now that we are done discussing how we fetch images from assets let‚Äôs build and run the project. In the app swipe up to view all the photos in the user‚Äôs photo library. Hooray üôå‚úäü•≥üéâüëè our collectionview now has images! How to Retrieve Images from Assets.Displaying Album AssetsNavigate back to the ViewController.swift file and find the handleOpenAlbumVC method in the marked MediaPickerViewDelegate section. Replace the code in the handleOpenAlbumVC method with the one below://MARK: - MediaPickerViewDelegatefunc handleOpenAlbumVC() { // 1 let albumVC = AlbumVC(smartAlbums: smartAlbums, userCreatedAlbums: userCreatedAlbums) albumVC.modalPresentationStyle = .custom albumVC.transitioningDelegate = self albumVC.delegate = self present(albumVC, animated: true, completion: nil)} Here we are injecting the smart albums and user created albums we fetched into the albumVC initializer right before the albumVC is modally presented.Now with the AlbumVC injected with the album assets, let‚Äôs use the assets to display the albums.Displaying the cover image for an album is simply a matter of requesting each album‚Äôs cover image from the PHImageManager. The AlbumVC is almost set up to display albums, let us complete the setup process and get it working.Head to the AlbumVC.swift file in the Controllers folder and add this below the marked properties section:// 1fileprivate lazy var smartAlbumSection = [SmartAlbumItem(albumName: \"Search\", imageName: \"magnifyingglass\"), SmartAlbumItem(albumName: \"Recents\", imageName: \"clock\", collection: smartAlbums[0]), SmartAlbumItem(albumName: \"Favorites\", imageName: \"heart\", collection: smartAlbums[1]), SmartAlbumItem(albumName: \"Videos\", imageName: \"play.circle\", collection: smartAlbums[2]), SmartAlbumItem(albumName: \"Screenshots\", imageName: \"iphone\", collection: smartAlbums[3]) ] The smartAlbumSection is an array of SmartAlbumItems. This is a simple struct to power our tableView‚Äôs first section.Each item holds a albumName, imageName, and an optional PHAssetCollection(the actual smart-album). The PHAssetCollection property of the SmartAlbumItem is optional because we know the first item (the Search item) in the smartAlbumSection array will not a have a PHAssetCollection property.Now scroll to the marked TableView Protocols section and let‚Äôs update the tableView‚Äôs cellForRowAt, didSelectRowAt, and numberOfRowsInSection methods to display our album‚Äôs UI:Add the cellForRowAt methodfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let sectionType = albumSections[indexPath.section] switch sectionType { case .smartAlbums: let smartAlbumCell = dequeSmartAlbumCell(for: indexPath) return smartAlbumCell case .userCreatedAlbums: let userCreatedAlbumCell = dequeUserCreatedAlbumCell(for: indexPath) return userCreatedAlbumCell } } Here we deque each cell based on the album section type. Where section 0 is a smartAlbumCell and 1 is a userCreatedAlbumCell.Above the cellForRowAt method update the dequeSmartAlbumCell method:fileprivate func dequeSmartAlbumCell(for indexPath: IndexPath) -&gt; UITableViewCell { //1 cell dequeing let smartAlbumCell = tableView.dequeueReusableCell(withIdentifier: smartAlbumCellIdentifier, for: indexPath) smartAlbumCell.backgroundColor = .clear smartAlbumCell.selectionStyle = .none //2 configuring SmartAlbumCell's UI and data binding let album = smartAlbumSection[indexPath.row] var contentConfig = smartAlbumCell.defaultContentConfiguration() contentConfig.text = album.albumName let config = UIImage.SymbolConfiguration(pointSize: 15, weight: .semibold, scale: .large) let image = UIImage(systemName: album.imageName, withConfiguration: config)?.withRenderingMode(.alwaysTemplate) contentConfig.image = image contentConfig.imageProperties.tintColor = .white contentConfig.textProperties.color = .white contentConfig.imageToTextPadding = 12 smartAlbumCell.contentConfiguration = contentConfig return smartAlbumCell } Here we are dequeing each smartAlbumCell. Configuring each smartAlbumCell with the new iOS 14.0+ tableview cell‚Äôs UI configurations. Then binding the smartAlbumSection data to display each smartAlbumCell‚Äôs title and icon.Right below the dequeSmartAlbumCell method, update the dequeUserCreatedAlbumCell method:fileprivate func dequeUserCreatedAlbumCell(for indexPath: IndexPath) -&gt; AlbumCell { // 1 let userCreatedAlbumCell = tableView.dequeueReusableCell(withIdentifier: userCreatedAlbumCellIdentifier, for: indexPath) as! AlbumCell userCreatedAlbumCell.backgroundColor = .clear userCreatedAlbumCell.selectionStyle = .none // 2 var coverAsset: PHAsset? let aUserCreatedAlbum = userCreatedAlbums[indexPath.item] // 3 let fetchOptions = PHFetchOptions() fetchOptions.fetchLimit = 1 let sortDescriptor = NSSortDescriptor(key: \"creationDate\", ascending: false) fetchOptions.sortDescriptors = [sortDescriptor] // 4 let fetchedAssets = PHAsset.fetchAssets(in: aUserCreatedAlbum, options: fetchOptions) coverAsset = fetchedAssets.firstObject guard let asset = coverAsset else { return userCreatedAlbumCell } // 5 let coverImage = getAssetThumbnail(asset: asset, size: userCreatedAlbumCell.bounds.size) userCreatedAlbumCell.bindData(albumTitle: aUserCreatedAlbum.localizedTitle ?? \"\", albumCoverImage: coverImage) return userCreatedAlbumCell } Here we are dequeing each userCreatedAlbumCell. Here we create variables to hold an album‚Äôs photo asset, which we‚Äôll use as the album‚Äôs cover image. And another variable to get each user-created album‚Äôs asset from our smart album assets. Since we only want to fetch the most recent image in each user-created album, we use PHFetchOptions‚Äôs fetchLimit and sortDescriptor to limit our fetch result to the most recently added asset in the album. We retrieve the album‚Äôs first asset using the PHAsset‚Äôs fetchAssets method (which is a PHFetchResult object) and set it as the cover asset. We grab the cover asset‚Äôs image from PhotoKit‚Äôs PHImageManager using our getAssetThumbnail method and then bind the title and image data to power our album cell‚Äôs UI. Add the numberOfRowsInSection method func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { switch albumSections[section] { case .smartAlbums: return smartAlbumSection.count case .userCreatedAlbums: return userCreatedAlbums.count } } Here we return the number of items in each section based on the album section type, so the tableView knows how many items to display in each section.Add the didSelectRowAt methodfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { switch albumSections[indexPath.section] { //1 case .smartAlbums: if let smartAlbum = smartAlbumSection[indexPath.row].collection { delegate?.handleDidSelect(album: smartAlbum) } else { delegate?.handlePresentPHPickerViewController() } dismiss(animated: true) // 2 case .userCreatedAlbums: delegate?.handleDidSelect(album: userCreatedAlbums[indexPath.row]) dismiss(animated: true) } } When the user selects an item in the smart-album section, we delegate the action to the parent ViewController.swift file, which is responsible for fetching all the photo or video assets in the selected album. Then we dismiss the AlbumVC. And if the user selects the search item we also delegate the ViewController.swift to present a PHPickerViewController, more on that later. On selection of an item in the user created-albums section we delegate the action to the ViewController.swift file and dismiss the AlbumVC. Run the project and open the albums. You should see albums with their names and cover images being displayed!Hooray üôå‚úäü•≥üéâüëè we are done displaying albums, all that‚Äôs left is changing our mediaPickerView‚Äôs photo assets to show the selected album‚Äôs photo assets when didSelectRow method is triggered in the AlbumVC. Hooray üôå‚úäü•≥üéâüëè we can now see our albums! How to Fetch Smart Albums and User-Created Albums. How to use the retrieved PHAssets and PHAssetCollections to power our UI.Fetching Selected Album‚Äôs Photo AssetsTo display the selected album‚Äôs photos in our mediaPickerView‚Äôs UI, navigate back to the ViewController.swift file. Locate the handleDidSelect method below the marked AlbumVCDelegate section and add the following code to it: func handleDidSelect(album: PHAssetCollection) { let fetchOptions = PHFetchOptions() let sortDescriptor = NSSortDescriptor(key: \"creationDate\", ascending: false) fetchOptions.sortDescriptors = [sortDescriptor] let fetchedAssets = PHAsset.fetchAssets(in: album, options: fetchOptions) allPhotosInCurrentAlbum = fetchedAssets mediaPickerView.bindDataFromPhotosLibrary(fetchedAssets: allPhotosInCurrentAlbum, albumTitle: album.localizedTitle ?? \"\") } Pretty self-explanatory from our Fetching The Assets section. Here we are simply fetching the selected album‚Äôs assets and passing it to our mediaPickerView for UI update.Now let‚Äôs run the project, open the albums and select any album, you should see the mediaPickerView‚Äôs photo assets update to display the selected album‚Äôs photos. Hooray üôå‚úäü•≥üéâüëè we can now change albums! How to Fetch all Photo Assets in a Specific Album.Searching Photo Library Assets Using PHPickerViewControllerThe first item in our smart album section is a search item. To mimic the instagram app‚Äôs design of this UX flow we will be using the PHPickerViewController. A view controller that was introduced in iOS 14+ as an alternative to UIImagePickerController for providing the user interface to search and pick photos from the photo library.The PHPickerViewController uses the traditional delegate model that will alert you upon user interation completion.Still in the ViewController.swift file, locate the handlePresentPHPickerViewController method which is below the marked AlbumVCDelegate section and update it content to this:func handlePresentPHPickerViewController() { // 1 DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) { // 2 var configuration = PHPickerConfiguration(photoLibrary: PHPhotoLibrary.shared()) configuration.selectionLimit = 10 // 3 let picker = PHPickerViewController(configuration: configuration) picker.delegate = self self.present(picker, animated: true, completion: nil) } } We are using the DispatchQueue‚Äôs async delay method to ensure that the AlbumVC was dismissed before we attempt to present the PHPickerViewController. The PHPickerConfiguration enables us to set a multi-selection limit, which we set to 10. We instantiate the PHPickerViewController and set it‚Äôs delegate before presenting it. Note: We can also filter the type of media that is presented to the user via PHPickerViewController by using configuration.filter = .images or configuration.filter = .any(of: [.livePhotos, .images]).PHPickerViewControllerDelegateJust below the handlePresentPHPickerViewController method we have the marked PHPickerViewControllerDelegate section. Update the picker() method to this:func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) { // 1 dismiss(animated: true) let identifiers = results.compactMap(\\.assetIdentifier) let fetchResult = PHAsset.fetchAssets(withLocalIdentifiers: identifiers, options: nil) // 2 DispatchQueue.main.async { self.mediaPickerView.bindDataFromPhotosLibrary(fetchedAssets: fetchResult, albumTitle: \"Search Result\") } } First we dismiss the PHPickerViewController upon completion of asset selection. Then we retrieve the selected assets using PHAsset‚Äôs fetchAssets method with the assetIdentifier property. We pass the retrieved assets off to be displayed by the mediaPickerView‚Äôs UI. Now let‚Äôs run the project, open the album and tap the search item. The PHPickerViewController will present a familiar UI of your photos and albums. Search and select photos and then tap the add button to dismiss. You should have something similar to this happening: PHPickerViewController Search Demo How to use PHPickerViewController to search and select specific assets.Listening For Changes Using PHPhotoLibraryChangeObserverNow that our app is running nicely let‚Äôs address how to handle changes in the photos library.We listen to changes in the photos library such as when a photo is deleted, added or edited by subscribing to the PHPhotoLibraryChangeObserver.According to Apple‚Äôs own documentation, the PHPhotoLibraryChangeObserver protocol notifies you of changes that occur in the photo library, regardless of whether those changes are made by your app, by a user in the Photos app, or by another app that uses the Photos framework.Listening For Changes in ViewControllerTo register for updates in the ViewController.swift file navigate to the fetchPhotoLibraryAssets method. Add this registration code anywhere below the PHPhotoLibrary.authorizationStatus() logic:fileprivate func fetchPhotoLibraryAssets() { // 1 let authStatus = PHPhotoLibrary.authorizationStatus() guard authStatus == .authorized || authStatus == .limited else {return} // ADD THIS LINE OF CODE BELOW 1. // Please note We are only subscribing to PHPhotoLibraryChangeObserver if we have authorization to access photo library. PHPhotoLibrary.shared().register(self).... } With our ViewController.swift listening for changes. Add this in the deinit method to remove the listener.deinit { PHPhotoLibrary.shared().unregisterChangeObserver(self)} Scroll down to the end of the ViewController.swift file and conform to the PHPhotoLibraryChangeObserver protocol with the following code://MARK: - PHPhotoLibraryChangeObserverextension ViewController: PHPhotoLibraryChangeObserver { // 1. func photoLibraryDidChange(_ changeInstance: PHChange) { DispatchQueue.main.async { // 2. if let changeDetails = changeInstance.changeDetails(for: self.allPhotosInCurrentAlbum) { self.allPhotosInCurrentAlbum = changeDetails.fetchResultAfterChanges // 3. self.mediaPickerView.bindDataFromPhotosLibrary(fetchedAssets: self.allPhotosInCurrentAlbum, albumTitle: self.mediaPickerView.getCurrentAlbumTitle()) } } }} The change observer has only one method: photoLibraryDidChange(:). Every time the photo library changes, it triggers this method. We need to check if the update affects our allPhotosInCurrentAlbum assets. Using changeInstance, a property that describes the photo library changes, by calling its changeDetails(for:) method and passing in our asset. It returns nil if our allPhotosInCurrentAlbum assets is not affected by the changes. Otherwise, we retrieve the updated copy of the allPhotosInCurrentAlbum assets by calling fetchResultAfterChanges. Refreshing the mediaPickerView‚Äôs UI to reflect the changes. Listening For Changes in AlbumVCSimilar to what we just did in the ViewController.swift file, let‚Äôs go to the AlbumVC.swift file to register for changes in album assets.Find the viewDidLoad method in the albumVC and modify it to this: override func viewDidLoad() { super.viewDidLoad() setUpTableView() view.backgroundColor = .clear // ADD THIS TO VIEWDIDLOAD let authStatus = PHPhotoLibrary.authorizationStatus() if authStatus == .authorized || authStatus == .limited { PHPhotoLibrary.shared().register(self) } }Here we are registring for changes only if we are authorized to access photo library.Similar to before lets remove the ChangeObserver listener in the deinit method. Add this anywhere in the marked Init section of your AlbumVC:deinit { PHPhotoLibrary.shared().unregisterChangeObserver(self) }Scroll down to the end of the AlbumVC.swift file and conform to the PHPhotoLibraryChangeObserver protocol with the following code://MARK: - PHPhotoLibraryChangeObserverextension AlbumVC: PHPhotoLibraryChangeObserver { func photoLibraryDidChange(_ changeInstance: PHChange) { DispatchQueue.main.async { //1. if let changeDetails = changeInstance.changeDetails(for: self.userCreatedAlbums) { self.userCreatedAlbums = changeDetails.fetchResultAfterChanges } self.tableView.reloadData() } } } Since only the user-created album section has cover images, that‚Äôs the only assets we should be listening to for changes.We check if the update affects our userCreatedAlbums assets. Use changeInstance with it‚Äôs changeDetails(for:) method to retrieve the updated copy of the userCreatedAlbums assets by calling fetchResultAfterChanges.Voil√†! just like that our AlbumVC.swift and ViewController.swift files are now listening for any changes that occurs in the photo library! How to use the PHPhotoLibraryChangeObserver protocol to keep our assets up to date.Congratulations!You did it! üôå‚úäü•≥üéâüëè you just replicated Instagram story‚Äôs custom photo picker. That was a lot to digest in a short time, hopefully you got a good introduction to the power of apple‚Äôs photokit framework. Remember to download the source code.So far we‚Äôve covered: How to Setup and Ask for User‚Äôs Photo Library Permission. How to Fetch Smart Albums and User-Created Albums. How to Fetch all Photo Assets in a Specific Album. How to Retrieve Images from Assets. How to use the retrieved PHAssets and PHAssetCollections to power our UI. How to use PHPickerViewController to search and select specific assets. How to use the PHPhotoLibraryChangeObserver protocol to keep our assets up to date.What‚Äôs Next?The PhotoKit is a robust framework with much to offer. There is still so much we can do with the impressive library that‚Äôs beyond the scope of this tutorial. There are cool stuff like LivePhoto, video and the photo editing functionalities etc. Check out the Apple‚Äôs PhotoKit Documentation for more information.That‚Äôs all folks, I hope you liked the tutorial üëã." }, { "title": "The 18 Books I Read in 2021", "url": "/posts/My-2021-Readlist/", "categories": "BookList", "tags": "knowledge, learning, bookshelf, library", "date": "2022-06-01 22:33:00 -0500", "snippet": "The truth is, I started reading habitually again in 2020 during the lockdown for self-improvement. I saw it mainly as a tool to upskill myself and fill in the blind spots on my worldviews and business knowledge.Over the last few years the habit has slowly morphed from a pure utilitarian self-improvement tool into an integral part of my identity and how I relax. Lately I read out of curiosity and interest. As I have found The best books i enjoyed are the ones that expanded my knowledge base on areas of interest.The Black Swan By Nassim Nicholas TalebManaging risk is a central theme in our modern world. Rare events often prove to be a crux of history. Most of the time, those events are originally dismissed because they do not meet the center of a bell curve. Nonetheless, because of their potential to have great impact, planning for these events should be considered. Through philosophical discussion, Taleb seeks to change our thoughts to instead focus on these events as potentially impactful. He relies on research of the mathematician Beno√Æt Mandelbrot (of fractal fame) to illustrate how seemingly unlikely random events occur when looked at prospectively. There are so many great insights in this book, it‚Äôs just a must read for anyone who‚Äôs looking to expand their knowledge base on historically unpredictable events that define our world. 10/10 will read againThe Lean Startup By Eric Ries This book teaches entrepreneurs how to navigate the extreme uncertainties of starting a new venture. By using the scientific method to test ideas, validating and invalidating business hypotheses to arrive at Product Market Fit under the vehicle of a minimal viable product (MVP). Instead of creating elaborate business plans, The Lean Startup offers a framework for startups to test, learn, and adjust their strategy through a cycle of continuous improvement. This book for me along with Lean analytics, Growth Hacking and the Cold Start Problem unlocked a high level understanding of what it entails to kick-start a tech start-up.Evil by Design By Chris NodderSloth, pride, envy, greed, lust, anger, gluttony. The list of seven deadly sins provides a nice, tidy statement of fundamental human behavior. Each chapter in this book addresses one of these sins, pointing out the human characteristics that enable software designer to create persuasive interfaces that appeal to each weakness.The 57 patterns described in this book are strong mechanisms for persuasion. They can be used in digital and physical products to increase customer loyalty or to attract new customers. In addition, you can use this information to recognize and avoid being personally persuaded by these principles when they appear in sites you use.But why should design be based on evil? Simple: starting with evil means starting with real human behavior. This doesn‚Äôt mean that the result is evil. It means that understanding what each sin represents adds to an understanding of people and good design results from good understanding.Truly a good book to consider if you are a product developer or designer. Although some of the behavioral engineering insights might appear to have a Machiavelli‚Äôs ‚ÄúThe Prince‚Äù level of persuasiveness to them.Hooked By Nir EyalAs the sole developer of Grinn, this book gave me the blueprint on how to approached building social products. This was my first deep dive into the world of behavioral engineering. The hook model lays down all the essential ingredient necessary for technological diffusion of new social products. I have read this book 3 times since 2021, and intend to reread it more times. 10/10 Best Book I read for the Year.Skin In The Game By Nassim Nicholas TalebSkin In The Game is an assessment of asymmetries in human interactions, aimed at helping you understand where and how gaps in uncertainty, risk, knowledge, and fairness emerge, and how to close them.A book that is necessary to understand the world. It focuses on the distortions of symmetry and reciprocity in life: If you have the rewards, you must also get some of the risks, not let others pay the price of your mistakes. If you inflict risk on others, and they are harmed, you need to pay some price for it.Skin in the game, applied as a rule, reduces the effects of the following divergences that grew with civilization: those between action and cheap talk (tawk), consequence and intention, practice and theory, honor and reputation, expertise and charlatanism, concrete and abstract, ethical and legal, genuine and cosmetic, merchant and bureaucrat, entrepreneur and chief executive, strength and display.TL;DL ‚Üí If you do not take risks for your opinion, you are nothing. Another intellectual masterpiece by Nassim, this one belongs in every library.Only the Paranoid Survive By Andy GroveThis book is about dealing with difficult crises as a company, based on Andrew‚Äôs experience at running Intel. He presents a strategic model which can be used to adapt to crises and even to exploit and thrive based on them. He calls these SIPs (Strategic Inflection Points), that attempt to make the most from a company‚Äôs sink-or-swim moments.Fooled by Randomness By Nassim Nicholas TalebFooled By Randomness explains how luck, uncertainty, probability, human error, risk, and decision-making work together to influence our actions, set against the backdrop of business and specifically, investing, to uncover how much bigger the role of chance in our lives is, than we usually make it out to be.The 3 Key Takeaways from the book were ‚Üì Life is non-linear, which makes the rewards of continued effort disproportionately big. We need our irrational emotions to be able to decide. Enjoy randomness when it‚Äôs harmless and use stoicism to deflect it when it‚Äôs harmful.Growth Hacker Marketing By Ryan Holiday This book was a solid introduction to growth hacking for me. The author discuses the benefits of growth hacking and provides some examples to help you understand the power it has over traditional marketing.Biggest lesson: growth can be hacked, measured and scaled using a more scientific experimental and data-drive framework.The traditional marketing channels are broken. Holiday explains how companies that have come to rely on massive advertising budgets, infomercials, and a broadcast-only marketing focus are missing out on huge opportunities.In Growth Hacker Marketing, he introduces a new class of marketing professional‚Äîthe growth hacker‚Äîand shows how to apply their unconventional tactics to your business.Wanting By Luke BurgisIn the universe of desire, there is no clear hierarchy. People don‚Äôt choose objects of desire the way they choose to wear a coat in the winter. Instead of internal biological signals, we have a different kind of external signal that motivates these choices: models.Models are people or things that show us what is worth wanting. It is models‚Äînot our ‚Äúobjective‚Äù analysis or central nervous system‚Äîthat shape our desires. With these models, people engage in a secret and sophisticated form of imitation that Girard termed mimesis (mi-mee-sis), from the Greek word mimesthai (meaning ‚Äúto imitate‚Äù).Models are the gravitational centers around which our social lives turn. It‚Äôs more important to understand this now than at any other time in history.A wonderful book that takes a transformational deep dive into the origins of our desires. Highly recommended.Hacking Growth By Sean Ellis &amp; Morgan BrownGrowth Hacking is an area of business management that I‚Äôm deeply fascinated by. From the moment I read Growth Hacker Marketing by Ryan Holiday I knew I wanted to become a growth hacker someday. So i set out to consolidate every possible information I could find on subject. Hacking Growth by Sean Ellis was the answer to that endless desire for a more detailed explanation on the low level components of what it takes to growth hack a business.Growth Hacking in essence helps companies achieve breakout results by building a culture of continuous experimentation. It addresses the four levers of growth: acquisition, activation, retention, and monetization. It‚Äôs recommended for marketers, product managers, or anyone else that wants to drive product adoption or business growth. A fantastic book that I have read over 3 times in the last year. 10/10Traction By Gabriel Weinberg &amp; Justin Mares In ‚ÄúTraction‚Äù, the founder of search engine Duckduckgo, Gabriel Weinberg, shares a fresh way for businesses to think about different phases of growth, with practical tips on how to test and use 19 potential channels to get more customers and achieve massive growth. Why Traction ? To succeed a startup must grow quickly. Traction is the measurable evidence of customer demand. Depending on the nature of your business, it could be the number of app downloads, the number of free/paid subscribers, the number of sales transactions etc. It signals that your company is taking off, and makes it easier to attract investors, talents, partners and publicity. The sales and marketing channels through which you acquire customers are your ‚Äútraction channels‚Äù. This is one of those books you must read and reread as a startup founder, wanna-be enterpreneur or indie-dev. I know I will be coming back multiple times to reread this book over the coming years.The Growth Marketer‚Äôs Playbook By Jim HuffmanYou can probably already see the pattern here. Yes i know, I read alot of growth hacking books in the last 24 months. Quite frankly this was one of those junk books, I didn‚Äôt learn much from it besides the idea of compiling a customer target list on a spreadsheet. Not worth the read honestly, if you want more good literature on growth hacking just go for the sean ellis book on the topic.Contagious By Jonah BergerVirality isn‚Äôt born; it‚Äôs made.The 6 Principles of Virality ‚Üì ‚Üí People share things that make them look good to others. (Social Currency) ‚Üí Top of mind means tip of the tongue. (Triggers) ‚Üí When we care, we share. When it comes to virality arousal is king. (Emotion) ‚Üí If something is built to show, it‚Äôs built to grow. (Public) ‚Üí People like to pass along practical, useful information. News you can use. (Practical Value) ‚Üí Information travels under the guise of idle chatter. (Stories)These principles can be compacted into an acronym. Taken together, they spell STEPPS. This is a briliiant well written, concise and insightful book on how to create viral products. One of my favorite books that I have read thrice and will reread again in the future. 10/10Why things catch onExplosive Growth By Cliff LernerExplosive Growth is a Business Book where Lerner uses a compelling and inspiring narrative to give a step-by-step guidebook to achieve success. He combines lively, and often hilarious, storytelling with genius growth tactics and a variety of case studies to help entrepreneurs and new startups.I enjoyed reading this book. The story telling and some of the not to do list on it are wild. The concept of newsjacking as potential growth hack was also a eye opener for me, one i can‚Äôt wait to deploy in the near future.Influence By Robert CialdiniInfluence is about the six principles of persuasion useful for sales, marketing and negotiation. Professor Robert Cialdini says certain triggers can influence human decisions almost automatically. The six principles are: reciprocity, consistency, social proof, liking, authority and scarcity.Lean Analytics By Benjamin Yoskovitz &amp; Alistair Croll This is a very dense book that attempts to explain the world of data collection and analysis to new entrepreneurs. It shows how to use data as a powerful tool to find product market fit, build great product and maintain market dominance.The 3 big take aways are ‚Üì‚Üí Be data-informed, not data-driven.‚Üí All successful startups go through five distinct stages: Empathy, Stickiness, Virality, Revenue, and Scale.‚Üí Identify the stage your startup is currently at and determine the one metric that matters for each stage and ruthlessly prioritize it. This was by far the best book I have ever read on business analytics. It would be foolish not to read this book if you ever intend to build a tech startup. More visuals on the lean method below ‚Üì 5 distinct stages every startup goes through The lean method with the hook model" } ]
